# 主引导扇区

编写makefile方便使用:
```makefile
%.bin: %.asm
	nasm $< -o $@

master.img: boot.bin
	yes | bximage -hd -mode="flat" -size=16 -q master.img
	dd if=$< of=$@ bs=512 count=1 conv=notrunc

.PHONY: bochs
bochs:master.img
	bochs -q

.PHONY:clean
clean:
	rm -rf master.img
	rm -rf *.bin%      
```

## BIOS
Basic Input Output System

BIOS加电后自检并将主引导扇区加载到0x7c00的位置，并**跳转**到这里执行。
```
int 0x10; BOIS的系统调用，显示器相关功能
```
当然也可以不用BIOS提供的功能清空屏幕，但是这样很简单。

## 实模式
8086是16位的，实模式寻址：
```
mov ax, 0xb800
mov ds, ax
```

文本显示区域的内存是0xb8000，但是我们放到ds中的是0xb800，这是为什么？

这是因为8086鸡肋的寻址方式，CPU 16位的位宽想要访问1M的内存，也就是20位。引入了段寄存器(同样16bit)，寻址时将段寄存器的值左移4位，再加上偏移地址(所谓的段内偏移)。
> 有效地址 = 段地址 << 4 + 偏移地址


因为<<4位使得可以访问到1M的内存，但是有可能超出20位，于是又增加了**地址回绕机制**。

这就是A20总线的由来，之后的80286内存更大已经不需要地址回绕了，但是为了**后向兼容**，不得不先回绕，然后再开启A20总线，使超出1M的地址不再回绕，过上了宽裕的日子🤭

开启保护模式之后，段寄存器里就不再放段基址这种古早的方式了，而是变成了GDT的索引，有了更多的功能，之后再说。

## 主引导扇区的结构
总共**一个扇区**，512个字节

- 代码：446B
- 硬盘分区表：64B = 4*16B
- 魔数：典中典的最后的55AA两个字节

### 主要功能
- 读取**内核加载器**loader并**跳转执行**。

