# 内存检测

内存检测是内核加载器的重要功能。因为内核需要兼容各种各样的机器，而不同机器的内存有大有小，因此加载内核时必须要知道这台机器的内存是什么样的，这就是内存检测。

检测出哪块内存可以用，哪块内存不可以用，用**起始地址**和**长度**来表示这块内存。

幸运的是，BIOS提供了内存检测的功能，即`0x15 0xe820`，用ARDS来表示每一块内存：

## ARDS结构体

Address Range Descriptor Structure ARDS

| 字节偏移量 | 属性名称     | 描述                             |
| ---------- | ------------ | -------------------------------- |
| 0          | BaseAddrLow  | 基地址的低 32 位                 |
| 4          | BaseAddrHigh | 基地址的高 32 位                 |
| 8          | LengthLow    | 内存长度的低 32 位，以字节为单位 |
| 12         | LengthHigh   | 内存长度的高 32 位，以字节为单位 |
| 16         | Type         | 本段内存的类型                   |

可以看到，用内存的**基地址**和**长度**表示位置，用Type表示类型。

### Type类型字段

| Type 值 | 名称                 | 描述                                                                                 |
| ------- | -------------------- | ------------------------------------------------------------------------------------ |
| 1       | AddressRangeMemory   | 这段内存可以被操作系统使用                                                           |
| 2       | AddressRangeReserved | 内存使用中或者被系统保留，操作系统不可以用此内存                                     |
| 其他    | 未定义               | 未定义，将来会用到．目前保留． 但是需要操作系统一样将其视为ARR(AddressRangeReserved) |

只有`Type == 1`即类型为`AddressRangeMemory`才表示这块内存**可以被内核使用**。

### 调用前输入

如何使用BIOS提供的这个`0X15`功能呢？

| 寄存器或状态位 | 参数用途                                                                                                                                                                                                                                                                                                 |
| -------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| EAX            | 子功能号： EAX 寄存器用来指定子功能号，此处输入为 0xE820                                                                                                                                                                                                                                                 |
| EBX            | 内存信息需要按类型分多次返回，由于每次执行一次中断都只返回一种类型内存的ARDS 结构，所以要记录下一个待返回的内存ARDS，在下一次中断调用时通过此值告诉 BIOS 该返回哪个 ARDS，这就是后续值的作用。第一次调用时一定要置为0，EBX 具体值我们不用关注，字取决于具体 BIOS 的实现，每次中断返回后，BIOS 会更新此值 |
| ES: DI         | ARDS 缓冲区：BIOS 将获取到的内存信息写入此寄存器指向的内存，每次都以 ARDS 格式返回                                                                                                                                                                                                                       |
| ECX            | ARDS 结构的字节大小：用来指示 BIOS 写入的字节数。调用者和 BIOS 都同时支持的大小是 20 字节，将来也许会扩展此结构                                                                                                                                                                                          |
| EDX            | 固定为签名标记 `0x534d4150`，此十六进制数字是字符串 `SMAP` 的ASCII 码： BIOS 将调用者正在请求的内存信息写入 ES: DI 寄存器所指向的ARDS 缓冲区后，再用此签名校验其中的信息                                                                                                                                 |
BIOS会将获取到的内存信息ARDS写入到`ES: DI`处的**内存中**，这样就方便操作了😄


### 返回值

调用完BIOS的`0x15`功能后，返回值如下：
| 寄存器或状态位 | 参数用途                                                                                                                                                                                                                                   |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| CF 位          | 若CF 位为 0 表示调用未出错，CF 为1，表示调用出错                                                                                                                                                                                           |
| EAX            | 字符串 SMAP 的 ASCII 码 `0x534d4150`                                                                                                                                                                                                       |
| ES:DI          | ARDS 缓冲区地址，同输入值是一样的，返回时此结构中己经被BIOS 填充了内存信息                                                                                                                                                                 |
| ECX            | BIOS 写入到 ES:DI 所指向的 ARDS 结构中的字节数，BIOS 最小写入 20 字节                                                                                                                                                                      |
| EBX            | 后续值：下一个 ARDS 的位置。每次中断返回后，BIOS 会更新此值， BIOS 通过此值可以找到下一个待返回的 ARDS 结构，咱们不需要改变 EBX 的值，下一次中断调用时还会用到它。在 CF 位为 0 的情况下，若返回后的 EBX 值为 0，表示这是最后一个 ARDS 结构 |

## 实现

### 获取ARDS并存入内存
在内核加载器中实现内存检测，将读出来的ARDS存放在`ards_buffer`的内存位置，其实就是loader本身的最后：
```s
[org 0x1000]

; 手写一个简单的loader内核加载器
dw 0x55aa ; 自定义一个魔数嘻嘻

mov si, loading
call print

xchg bx, bx
detect_memory:
    xor ebx, ebx;
    
    mov ax, 0
    mov es, ax ;段寄存器不能直接改
    mov edi, ards_buffer ;结果存放位置，就在下文loader靠后的位置

    mov edx, 0x534d4150; 固定签名
.next:
    mov eax, 0xe820 ;子功能号
    mov ecx, 20 ;ARDS的大小
    int 0x15; BIOS中断

    jc error ;CF置位表示出错

    add di, cx
    inc word [ards_count]; 结构体数量加一
    cmp ebx, 0
    jnz .next

    mov si, detecting ;检测结束
    call print

jmp $

print:
    mov ah, 0x0e
.next:
    mov al, [si]
    cmp al, 0
    jz .done
    int 0x10
    inc si
    jmp .next
.done:
    ret
loading:
    db "Loading MyOS...", 10, 13, 0 ;最后三个数字依次代表/n /r /0的ASCII码
detecting:
    db "Detecting Memory Success...", 10, 13, 0 ;最后三个数字依次代表/n /r /0的ASCII码
    
error:
    mov si, .msg
    call print
    hlt ;让CPU停止
    jmp $ ;阻塞
    .msg: db "Loading Error!!!" , 10, 13, 0

ards_count:
    dw 0

ards_buffer: ;loader的最后，防止覆盖loader自己

```

### 分析内存中的ARDS

在上面的基础上，也就是检测成功后：
```s
...
    mov si, detecting ;检测结束
    call print
    
    mov cx, [ards_count] ;ards的数量
    mov si, 0 ;结构体指针
.show:
    mov eax, [ards_buffer + si] ;eax表示基地址
    mov ebx, [ards_buffer + si + 8] ;ebx表示长度
    mov edx, [ards_buffer + si + 16] ;edx表示类型
    add si, 20 ;结构体大小
    xchg bx, bx
    loop .show
```

注意`loop`指令会自动检测ecx或者edx的值，自动--直到0跳出循环。

这样我们单步调试，就可以根据eax, ebx, edx看看每段内存的类型了😄当然只是通过寄存器简单看了一下，之后用C语言应该更方便。